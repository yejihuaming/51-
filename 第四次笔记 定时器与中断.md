# 定时器工作原理与工作模式，初值计算
定时器是一种内部资源，完成软件计时，相对于传统单片机多了1个计时器（52为3个）
## 工作原理
根据时钟输出信号，每个“一个单位时间”计数器加一，增加到指定时间时，向中断系统发送中断申请，使程序跳转到中断服务函数进行
## 工作模式
<img width="914" height="631" alt="Snipaste_2026-02-18_00-05-50" src="https://github.com/user-attachments/assets/0776a58b-f678-4663-af27-a2803dcf33dc" />

<img width="928" height="717" alt="Snipaste_2026-02-17_23-52-01" src="https://github.com/user-attachments/assets/1a723879-347f-43f3-9e78-450d58a3ac57" />

主要用工作方式1
<img width="866" height="451" alt="Snipaste_2026-02-17_23-57-06" src="https://github.com/user-attachments/assets/a8efc8e3-7d5d-4412-8eca-c3609164ca34" />

一般GATE给0；即启动不受外部中断信号影响

<img width="913" height="573" alt="Snipaste_2026-02-18_00-00-41" src="https://github.com/user-attachments/assets/5645b6af-4cdf-4b3e-83e8-f1e90fde35f2" />

<img width="914" height="631" alt="Snipaste_2026-02-18_00-05-50" src="https://github.com/user-attachments/assets/eb4d2eb3-0308-4503-8b53-c52ba14ff490" />

单位为微秒，当以毫秒为计数单位时要乘1000；定时器0把初值寄存在TH0（初值高八位）、TL0（初值低八位），定时器1在TH1、TL1
8位有自动重置初值，13、16位要手动
# 计时器代替阻塞延时函数
与延时函数的区别为减少CPU的占用，可同时进行多个任务的处理
## 代码
```c
#include <REGX52.H>

void inittimer()
{
	ET0 = 1;//¿ªÊ¼¶¨Ê±Æ÷0µÄÖÐ¶Ï
	EA = 1;//¿ªÊ¼×ÜÖÐ¶Ï
	TR0 = 1;//Æô¶¯¶¨Ê±Æ÷0
	TMOD =0X01;
	TH0 = 64613/256;
	TL0 = 64613%256;
	P1_0 = 0;
}
void main()
{
	inittimer();
	while(1)
	{
	}
}
int count = 0;
void timer_isr()	interrupt  1//0ÊÇÍâ²¿ÖÐ¶Ï0;1ÊÇ¶¨Ê±Æ÷ÖÐ¶Ï0£¬2ÊÇÍâ²¿ÖÐ¶Ï1£»3ÊÇÍâ²¿ÖÐ¶Ï1£»4ÊÇ´®¿ÚÖÐ¶Ï
{
	count++;
	TH0 = 64613/256;
	TL0 = 64613%256;
	if(count>=1000){
		count = 0;
		P1_0 = ~P1_0;
	}
}
```
## 演示视频
https://github.com/user-attachments/assets/e7d17da8-2dce-495b-86ab-b05d3c0ecaf3

# 定时器控制流水灯
TMOD&0XF0///高四位不变，低四位清零
TMOD|0X01//高四位不变，低四位清零
优先级：外部中断0>定时器中断0>外部中断1>定时器中断1>串口中断
## 代码
```c
#include <REGX52.H>
#include <intrins.h>
void inittimer()
{
	ET0 = 1;//¿ªÊ¼¶¨Ê±Æ÷0µÄÖÐ¶Ï
	EA = 1;//¿ªÊ¼×ÜÖÐ¶Ï
	TR0 = 1;//Æô¶¯¶¨Ê±Æ÷0
	TMOD =0X01;
	TH0 = 64613/256;
	TL0 = 64613%256;
	P1 = 0X01;
}
void main()
{
	inittimer();
	while(1)
	{
		
	}
}
void timer_isr()	interrupt  1//0ÊÇÍâ²¿ÖÐ¶Ï0;1ÊÇ¶¨Ê±Æ÷ÖÐ¶Ï0£¬2ÊÇÍâ²¿ÖÐ¶Ï1£»3ÊÇÍâ²¿ÖÐ¶Ï1£»4ÊÇ´®¿ÚÖÐ¶Ï
{
	static int count = 0;
	count++;
	TH0 = 64613/256;
	TL0 = 64613%256;
	if(count>=1000){
		count = 0;
		P1= _crol_(P1,1);
	}
}
```
## 演示视频
采用的是循环左移的方法实现的流水灯，故到第五个灯熄灭后没有立即使第一个灯亮

https://github.com/user-attachments/assets/f16de9bd-b037-4515-ba93-52c914acd2a3

# 计时器控制数码管0~99显示
演示视频为展示到99，但实测到99后清零，用了两个计时器，一个负责数的转换，一个负责显示的转换
```c
#include <REGX52.H>
#include <intrins.h>
char number[10] = {0X3F,0X06,0X5B,0X4F,0X66,0X6D,0X7D,0X07,0X7F,0X6F};
int flag = 0;
int i=0,j=0;
void inittimer()
{
	ET0 = 1;
	EA = 1;
	TR0 = 1;
	
	TMOD =0X11;
	
	ET1 = 1;
	TR1 = 1;
	
	TH1 = 64613/256;
	TL1 = 64613%256;
	
	TH0 = 64613/256;
	TL0 = 64613%256;
	
	P2 = 0X00;
	P3 = 0X00;
}
void main()
{
	inittimer();
	while(1)
	{
			
	}
}
void timer_isr0()	interrupt  1
{
	static int count=0;
	count++;
	TH0 = 64613/256;
	TL0 = 64613%256;
	if(count>=1000){
		count = 0;
		j++;
		if(j>9)
		{
			i++;
			j=0;
			if(i>9)
			{
				i = 0;
			}
		}
	}
}
void timer_isr1() interrupt  3
{
	static int count=0;
	count++;
	TH1 = 64613/256;
	TL1 = 64613%256;
	if(count >=50&&count<100)
	{
		P3 = 0X00;
		P2 = number[i];
	}else if(count>=100)
	{
		P3 = 0X01;
		P2 = number[j];
		count = 0;
	}
}
```
## 演示视频

https://github.com/user-attachments/assets/a4ea9eb5-5cf6-4c93-9ca6-7570c9988716
